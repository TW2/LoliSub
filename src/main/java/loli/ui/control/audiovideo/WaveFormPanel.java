package loli.ui.control.audiovideo;

import loli.Sub;
import loli.enumeration.DrawColor;
import loli.helper.AssTime;
import loli.ui.MainFrame;

import loli.ui.dialog.ProgressFrame;
import org.bytedeco.javacv.FFmpegFrameGrabber;
import org.bytedeco.javacv.Frame;
import org.bytedeco.javacv.FrameGrabber;

import javax.sound.sampled.AudioFormat;
import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.ByteBuffer;
import java.nio.ShortBuffer;
import java.nio.file.Path;
import java.sql.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * WaveFormPanel displays a waveform generated by db
 * We open the media, search for its length is microsecond
 * calculate the y to put to the db, and generate lines from y.
 * Data (y) are percent value where center (getHeight() / 2) is zero
 * and the restant height / 2 is 100% meaning y is per example 55%.
 */
public class WaveFormPanel extends JPanel {

    private final Path dbPath;

    private final MainFrame mainFrame;

    private long offsetMicros;
    private long periodMicros;
    private long durationMicros;
    private BufferedImage image;

    private Color backgroundColor;
    private Color waveColor;

    private Color areaStartColor;
    private Color areaEndColor;
    private Color areaOverlay;
    private Color mouseColor;
    private Color keyFramesColor;
    private Color secondsMarkColor;
    private Color minutesMarkColor;
    private Color hoursMarkColor;

    private Point mouseMovePoint;
    private Point mouseStartPoint;
    private Point mouseEndPoint;

    public WaveFormPanel(MainFrame mainFrame) {
        setDoubleBuffered(true);
        this.mainFrame = mainFrame;

        dbPath = Path.of(Path.of("").toAbsolutePath() + "\\conf\\audio.db");

        durationMicros = -1L;
        image = null;

        backgroundColor = DrawColor.dark_slate_blue.getColor();
        waveColor = Color.red;

        areaStartColor = Color.green;
        areaEndColor = Color.yellow;
        areaOverlay = DrawColor.black.getColor(.3f);
        mouseColor = Color.white;
        keyFramesColor = DrawColor.cyan.getColor(.7f);
        secondsMarkColor = Color.pink;
        minutesMarkColor = Color.magenta;
        hoursMarkColor = DrawColor.alice_blue.getColor();

        mouseMovePoint = null;
        mouseStartPoint = null;
        mouseEndPoint = null;

        addMouseMotionListener(new MouseMotionAdapter() {
            @Override
            public void mouseMoved(MouseEvent e) {
                super.mouseMoved(e);

                mouseMovePoint = e.getPoint();
                repaint();
            }
        });

        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                super.mouseClicked(e);

                // offset micros <> x --- periodMicros <> width
                double ox = (double)offsetMicros * (double)getWidth() / (double)periodMicros; // OK

                AssTime t = getTime(e.getX()); // OK

                if(e.getButton() == MouseEvent.BUTTON1){
                    // Left button
                    mouseStartPoint = new Point(e.getX() + (int)ox, e.getY()); // OK
                    mainFrame.getTablePanel().getEditor().setToLockStart(t); // OK
                    mainFrame.getAudioPanel().setMicrosStart((long) t.getMsTime() * 1_000L); // OK
                    mainFrame.getVideoPanel().setMicrosStart((long) t.getMsTime() * 1_000L); // OK
                }

                if(e.getButton() == MouseEvent.BUTTON3){
                    // Right button
                    mouseEndPoint = new Point(e.getX() + (int)ox, e.getY()); // OK
                    mainFrame.getTablePanel().getEditor().setToLockEnd(t); // OK
                    mainFrame.getAudioPanel().setMicrosEnd((long) t.getMsTime() * 1_000L); // OK
                    mainFrame.getVideoPanel().setMicrosEnd((long) t.getMsTime() * 1_000L); // OK
                }

                repaint();
            }
        });
    }

    public void open(String media) throws FrameGrabber.Exception {

        // Open the file to read data...
        FFmpegFrameGrabber grabber = new FFmpegFrameGrabber(media);

        grabber.start();

        durationMicros = grabber.getLengthInTime();

        grabber.stop();
        grabber.release();
        grabber.close(); // ...and close

        // Start thread to read samples and write data y to sqlite db
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        executorService.submit(() -> {
            // public void run()

            try(
                    // create a database connection
                    Connection connection = DriverManager.getConnection("jdbc:sqlite:" + dbPath.toAbsolutePath());
                    Statement statement = connection.createStatement();
            ){
                // 1/ Clear database
                statement.executeUpdate("drop table if exists waveform");

                // 2/ Re/Create database
                // id index - sec seconds in double (x) - y percent in double (y)
                statement.executeUpdate("create table waveform (id integer, micros integer, y integer)");

                // 3/ Open media and insert data
                createData(media, statement);

                // 4/ Autoclose
                System.out.println("OK: Waveform ready in DB");

                update(0L, 2_000_000L, 1d);

            }catch(SQLException e){
                // if the error message is "out of memory",
                // it probably means no database file is found
                e.printStackTrace(System.err);
            } catch (FrameGrabber.Exception e) {
                throw new RuntimeException(e);
            }
        });

        executorService.shutdown();
    }

    private void createData(String media, Statement statement) throws FrameGrabber.Exception, SQLException {
        FFmpegFrameGrabber grabber = new FFmpegFrameGrabber(media);

        grabber.start();

        // Check that we have a conform audio file
        AudioFormat format;
        if (grabber.getAudioChannels() > 0) {
            // Source format
            format = new AudioFormat(
                    grabber.getSampleRate(),
                    16,
                    grabber.getAudioChannels(),
                    true,
                    true
            );
        }else{
            // Or stop and return
            grabber.stop();
            grabber.release();
            grabber.close();
            System.err.println("Error 1");
            return;
        }

        long lastCurrentMicros = 0L;
        ProgressFrame loading = new ProgressFrame(this);
        loading.showLoading(durationMicros);

        int index = 0;

        while(true){
            final Frame frame;
            frame = grabber.grab();
            int p = loading.update(grabber.getTimestamp());
            if(p == 100) break;

            if (frame == null) {
                break; // TODO EOF
            }
            if (frame.samples != null) {
                final ShortBuffer channelSamplesShortBuffer = (ShortBuffer) frame.samples[0];
                channelSamplesShortBuffer.rewind();

                final ByteBuffer outBuffer = ByteBuffer
                        .allocate(channelSamplesShortBuffer.capacity() * 2);

                for (int i = 0; i < channelSamplesShortBuffer.capacity(); i++) {
                    short val = channelSamplesShortBuffer.get(i);
                    outBuffer.putShort(val);
                }

                // Samples in an array
                byte[] samples = outBuffer.array();

                // en stéréo (16)
                // On obtient le nombre de données à traiter
                int samplesLength = samples.length / 2;
                // x
                long currentMicros = grabber.getTimestamp();
                p = loading.update(currentMicros);
                if(p == 100) break;

                for(int i=0; i<samplesLength; i++){
                    if(currentMicros - lastCurrentMicros < 10_000L) continue;

                    //-----------------------------------------------------------
                    // 16 bits
                    //-----------------------------------------------------------
                    // Most significant bit, Low significant bit
                    // First MSB (high order), second LSB (low order) big endian
                    // or
                    // First LSB (low order), second MSB (high order) little endian
                    int MSB = format.isBigEndian() ? samples[2*i] : samples[2*i+1];
                    int LSB = format.isBigEndian() ? samples[2*i+1] : samples[2*i];
                    int value = MSB << 8 | (255 & LSB);
                    byte b = (byte)(128 * value / 32768);

                    // y
                    double y = ((double)getHeight() * (128 - b) / 256);

                    statement.executeUpdate("insert into waveform values(" +
                            index + "," + currentMicros + "," + y + ")");
                    index++;

                    lastCurrentMicros = currentMicros;
                }
            }                       /* end of if(frame.samples != null) */
        }                           /* end of while(!execThread.isInterrupted()) */

        loading.setVisible(false);
        loading.dispose();

        grabber.stop();
        grabber.release();
        grabber.close();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        // To call for repaint, use update(x,x,x) method

        Graphics2D g2d = (Graphics2D)g;
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        g2d.setColor(backgroundColor);
        g2d.fillRect(0, 0, getWidth(), getHeight());

        // Draw moment
        if(image != null){
            g2d.drawImage(image, 0, 0, null);

            // offset micros <> x
            // periodMicros <> width
            double ox = (double)offsetMicros * (double)getWidth() / (double)periodMicros;
            // Where 'OK', the 'ox' is well-used (if no 'ox', there is no need)

            if(mouseMovePoint != null){
                g2d.setColor(mouseColor);
                g2d.drawLine(mouseMovePoint.x, 0, mouseMovePoint.x, getHeight()); // OK
                String content = String.format("%s (%s)",
                        getTimePixels(mouseMovePoint.x), // OK
                        Sub.L.getString("waveCursor"));
                drawAssTime(g2d, content, -2, 0, -mouseMovePoint.x); // OK
            }

            if(mouseStartPoint != null){
                g2d.setColor(areaStartColor);
                Line2D line = new Line2D.Double(
                        mouseStartPoint.x - ox, 0, // OK
                        mouseStartPoint.x - ox, getHeight() // OK
                );
                g2d.draw(line);
                String content = String.format("%s (%s)",
                        getTimePixels(mouseStartPoint.x - (int)ox), // OK
                        Sub.L.getString("waveAreaStart"));
                drawAssTime(g2d, content, -2, 0, -mouseStartPoint.x + (int)ox); // OK
            }

            if(mouseEndPoint != null){
                g2d.setColor(areaEndColor);
                Line2D line = new Line2D.Double(
                        mouseEndPoint.x - ox, 0, // OK
                        mouseEndPoint.x - ox, getHeight() // OK
                );
                g2d.draw(line);
                String content = String.format("%s (%s)",
                        getTimePixels(mouseEndPoint.x - (int)ox), // OK
                        Sub.L.getString("waveAreaEnd"));
                drawAssTime(g2d, content, -2, 0, -mouseEndPoint.x + (int)ox); // OK
            }

            if(mouseStartPoint != null && mouseEndPoint != null
                    && mouseStartPoint != mouseEndPoint){
                g2d.setColor(areaOverlay);
                Rectangle2D rect = new Rectangle2D.Double(
                        mouseStartPoint.x - ox, 0, // OK
                        mouseEndPoint.x - mouseStartPoint.x, getHeight()
                );
                g2d.fill(rect);
            }

            long realMicros = 0L;
            for(long micros=-offsetMicros; micros<durationMicros-offsetMicros; micros+=100_000L){
                // Search for current rectangle frame
                if(micros > 0L && micros < periodMicros){
                    // Calculation of x
                    // width <> period
                    // x <> micros
                    int xc = (int)(((double) (micros * getWidth()) / periodMicros));
                    g2d.setColor(Color.magenta);
                    Stroke oldStroke = g2d.getStroke();
                    g2d.setStroke(new BasicStroke(
                            1f,
                            BasicStroke.CAP_ROUND,
                            BasicStroke.JOIN_ROUND,
                            2f,
                            new float[]{2f, 2f},
                            0)
                    );
                    g2d.drawLine(xc, 0, xc, getHeight());
                    g2d.setStroke(oldStroke);
                    AssTime t = new AssTime(realMicros / 1_000d);
                    drawAssTime(g2d, t.toAss(), -2, 0, -xc); // OK
                }
                realMicros += 100_000L;
            }
        }
    }

    public AssTime getTime(int x){
        // period <> max
        // m <> x
        long m = periodMicros * x / Math.max(1L, getWidth());
        return new AssTime((double) (m + offsetMicros) / 1_000d); // ms
    }

    public String getTimePixels(int x) {
        return getTime(x).toAss();
    }

    public void drawAssTime(Graphics2D g2d, String content, int rx, int ry, int x){
        // Rotation with anchor
        AffineTransform transform = new AffineTransform();
        transform.rotate(Math.toRadians(90), rx, ry);
        g2d.setTransform(transform);
        g2d.drawString(content, 5, x + 10);
        transform.rotate(Math.toRadians(-90), rx, ry);
        g2d.setTransform(transform);
    }

    public void update(long offsetMicros, long periodMicros, double verticalZoom){

        this.offsetMicros = offsetMicros;
        this.periodMicros = periodMicros;

        System.out.println(getWidth() + "x" + getHeight());
        image = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = image.createGraphics();
        g.setColor(waveColor);

        try(
                // create a database connection
                Connection connection = DriverManager.getConnection("jdbc:sqlite:" + dbPath.toAbsolutePath());
                Statement statement = connection.createStatement();
        ){
            long start = offsetMicros;
            long end = offsetMicros + periodMicros;

            double lastX = 0d, lastY = 0d;

            // 1/ Read data
            ResultSet rs = statement.executeQuery(
                    "select * from waveform where micros between " + start + " and " + end);
            while(rs.next()) {
                // read the result set
                long micros = rs.getLong("micros");
                double y = rs.getLong("y");

                // period <> width
                // micros - offset <> x
                double x = (((double)micros - (double)offsetMicros) * (double)getWidth() / (double)periodMicros);

                g.draw(new Line2D.Double(x, getHeight() / 2d, x, y));
                g.draw(new Line2D.Double(x, getHeight() / 2d, x, getHeight() - y));

                Polygon p = new Polygon();
                p.addPoint((int)lastX, (int)lastY);
                p.addPoint((int)x, (int)y);
                p.addPoint((int)x, (int)(getHeight() - y));
                p.addPoint((int)lastX, (int)(getHeight() - lastY));

                g.fill(p);

                g.draw(new Line2D.Float(0, getHeight()/2f, getWidth(), getHeight()/2f));

                lastX = x;
                lastY = y;
            }

            // 2/ Autoclose

        }catch(SQLException e){
            // if the error message is "out of memory",
            // it probably means no database file is found
            e.printStackTrace(System.err);
        }

        g.dispose();
        repaint();
    }

    public MainFrame getMainFrame() {
        return mainFrame;
    }

    public long getDurationMicros() {
        return durationMicros;
    }

    public Color getBackgroundColor() {
        return backgroundColor;
    }

    public void setBackgroundColor(Color backgroundColor) {
        this.backgroundColor = backgroundColor;
    }

    public Color getWaveColor() {
        return waveColor;
    }

    public void setWaveColor(Color waveColor) {
        this.waveColor = waveColor;
    }

    public Color getAreaStartColor() {
        return areaStartColor;
    }

    public void setAreaStartColor(Color areaStartColor) {
        this.areaStartColor = areaStartColor;
    }

    public Color getAreaEndColor() {
        return areaEndColor;
    }

    public void setAreaEndColor(Color areaEndColor) {
        this.areaEndColor = areaEndColor;
    }

    public Color getAreaOverlay() {
        return areaOverlay;
    }

    public void setAreaOverlay(Color areaOverlay) {
        this.areaOverlay = areaOverlay;
    }

    public Color getMouseColor() {
        return mouseColor;
    }

    public void setMouseColor(Color mouseColor) {
        this.mouseColor = mouseColor;
    }

    public Color getKeyFramesColor() {
        return keyFramesColor;
    }

    public void setKeyFramesColor(Color keyFramesColor) {
        this.keyFramesColor = keyFramesColor;
    }

    public Color getSecondsMarkColor() {
        return secondsMarkColor;
    }

    public void setSecondsMarkColor(Color secondsMarkColor) {
        this.secondsMarkColor = secondsMarkColor;
    }

    public Color getMinutesMarkColor() {
        return minutesMarkColor;
    }

    public void setMinutesMarkColor(Color minutesMarkColor) {
        this.minutesMarkColor = minutesMarkColor;
    }

    public Color getHoursMarkColor() {
        return hoursMarkColor;
    }

    public void setHoursMarkColor(Color hoursMarkColor) {
        this.hoursMarkColor = hoursMarkColor;
    }
}
